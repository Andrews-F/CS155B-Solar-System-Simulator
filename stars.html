<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color:#000;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}
		</style>
	</head>

	<body>
		<div id="container"></div>
		<div id="info">

		</div>

		<script src="three.js"></script>
		<script src="OrbitControls.js"></script>
		<script src="Detector.js"></script>
		<script src="dat.gui.min.js"></script>
		<script src="threex.dilategeometry.js"></script>
		<script src="threex.atmospherematerial.js"></script>
		<script src="threex.geometricglowmesh.js"></script>
		<script src="threex.atmospherematerialdatgui.js"></script>


		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
			var controls, scene, renderer;
			var solarCam,mercuryCam, venusCam, earthCam, marsCam, jupiterCam, saturnCam, uranusCam, neptuneCam;
			var clock;
			var sun, mercury, venus, earth, mars, jupiter, saturn, rings, uranus, neptune; // 1. Creating outerspace through the dome option: added the variable "space"

			// Radii
			var mercuryRadius = 75.34/2;
			var venusRadius = 80.37/2;
			var earthRadius = 84.51/2;
			var marsRadius = 92.34/2;
			var jupiterRadius = 147.38/2;
			var saturnRadius = 212.25/2;
			var uranusRadius = 356.65/2;
			var neptuneRadius = 519.26/2;


			var camControls = new function() {
					this.camera = "Solar View";
			}
			var gui = new dat.GUI();
			gui.add(camControls, 'camera',['Solar View','Mercury','Venus','Earth','Mars','Jupiter','Saturn','Uranus','Neptune']);

			init();
		//	render(); // remove when using next line for animation loop (requestAnimationFrame)
			animate();


			function init() {
				initScene();
				initRenderer();
				initSolarCam();
				initControls();
				// initBackground(); // 2. Creating outerspace through the dome option: remove "initBackground();"
				initPlanets();
				initPlanetPaths();
				initPlanetCams();
				initStarField();
				initLights();

				// Not sure what to do with this
				var container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );
			}

			function initBackground(){
				var materialColor = new THREE.MeshBasicMaterial({
						map: THREE.ImageUtils.loadTexture("../starry-deep-outer-space-galaxy.jpg"),
						depthTest: false
				});
				var bgPlane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), materialColor);
				bgPlane.position.z = -100;
				bgPlane.scale.set(window.innerWidth * 2, window.innerHeight * 2, 1);
				scene.add(bgPlane);
			}

			function initPlanets(){
				sun = createPlanetMesh("../sun.jpg",new THREE.SphereGeometry(69.55/4, 40, 40));
				sun.position.set(0,0,0);
				sun.add(createSunGlow()); //need to expand the glow
				scene.add(sun);

		// 3. Creating outerspace through the dome option
				// space = createOuterSpace('starry-deep-outer-space-galaxy.jpg');
				// scene.add(space);

				mercury = createPlanetMesh("../mercury.jpg",new THREE.SphereGeometry(.24*2, 40, 40));
				scene.add(mercury);
				venus = createPlanetMesh("../venus.jpg",new THREE.SphereGeometry(.61*2, 40, 40));
				scene.add(venus);
				earth = createPlanetMesh("../earth.png",new THREE.SphereGeometry(.64*2, 40, 40));
				scene.add(earth);
				mars = createPlanetMesh("../mars.jpg",new THREE.SphereGeometry(.34*2, 40, 40));
				scene.add(mars);
				jupiter = createPlanetMesh("../jupiter.jpg",new THREE.SphereGeometry(6.99, 40, 40));
				scene.add(jupiter);
				saturn = createPlanetMesh("../saturn.jpg",new THREE.SphereGeometry(5.82, 40, 40));
				scene.add(saturn);
       	rings = createRings(new THREE.CylinderGeometry(13.82, 13.82, .1, 100));
		    scene.add(rings);
				uranus = createPlanetMesh("../uranus.jpg",new THREE.SphereGeometry(2.54, 40, 40));
				scene.add(uranus);
				neptune = createPlanetMesh("../neptune.jpg",new THREE.SphereGeometry(2.46, 40, 40));
				scene.add(neptune);
			}

			function initStarField(){
				var star_geometry = new THREE.SphereGeometry(0.25, 8, 6);
				var star_material = new THREE.MeshBasicMaterial( { color: 0xffffe6, flatShading: true } );

				for ( var i = 0; i < 5000; i ++ ) {
				  var mesh = new THREE.Mesh(star_geometry, star_material);
				  // var glowMesh	= new THREEx.GeometricGlowMesh(mesh); mesh.add(glowMesh.object3d);
				  // var insideUniforms	= glowMesh.insideMesh.material.uniforms
				  // insideUniforms.glowColor.value.set('white')
				  // var outsideUniforms	= glowMesh.outsideMesh.material.uniforms
				  // outsideUniforms.glowColor.value.set('white')
				  // mesh.add(glowMesh);
					mesh.position.x = ( Math.random() - 0.5 ) * 1000;
					mesh.position.y = ( Math.random() - 0.5 ) * 1000;
					mesh.position.z = ( Math.random() - 0.5 ) * 1000;
					mesh.updateMatrix();
					mesh.matrixAutoUpdate = false;
					scene.add( mesh );
				}
			}

			function initPlanetPaths() {
				scene.add(createPlanetPath(mercuryRadius));
				scene.add(createPlanetPath(venusRadius));
				scene.add(createPlanetPath(earthRadius));
				scene.add(createPlanetPath(marsRadius));
				scene.add(createPlanetPath(jupiterRadius));
				scene.add(createPlanetPath(saturnRadius));
				scene.add(createPlanetPath(uranusRadius));
				scene.add(createPlanetPath(neptuneRadius));
			}

			function createPlanetPath(radius) {
				var material = new THREE.LineBasicMaterial( { color: 0xffffff } );
				var pathGeo = new THREE.CircleGeometry(radius,100);
				pathGeo.vertices.shift();
				var path = new THREE.Line(pathGeo, material);
				path.rotation.x = Math.PI/2;
				return path;
			}

			function initLights() {
				// lights
				// var light1 = new THREE.DirectionalLight( 0xffffff );
				// light1.position.set( 50,50,50 );
				// scene.add( light1 );
				// var helper1 = new THREE.DirectionalLightHelper(light1);
				// scene.add(helper1);
				// var light2 = new THREE.DirectionalLight( 0xffffff );
				// light2.position.set( -50,-50,-50 );
				// scene.add( light2 );
				// var helper2 = new THREE.DirectionalLightHelper(light2,5);
				// scene.add(helper2);
				// var light3 = new THREE.DirectionalLight( 0x002288 );
				// light3.position.set( -1, -1, 1 );
				// scene.add( light3 );
				var light3 = new THREE.AmbientLight( 0xffffff );
				scene.add( light3 );
			}

// 4. Creating outerspace through the dome option
			// function createOuterSpace(image, k) {

					// var geometry = new THREE.SphereGeometry( 500, 100, 100 );
					// var texture = new THREE.TextureLoader().load( '/images/'+image );
					// // texture.wrapS = THREE.RepeatWrapping;
					// // texture.wrapT = THREE.RepeatWrapping;
					// // texture.repeat.set( k, k );
					// var material = new THREE.MeshLambertMaterial( { color: 0xffffff,  map: texture ,side:THREE.DoubleSide} );
					// //var pmaterial = new Physijs.createMaterial(material,0.9,0.5);
					// //var mesh = new THREE.Mesh( geometry, material );
					// var mesh = new THREE.Mesh( geometry, material, 0 );

					// mesh.receiveShadow = false;
					// return mesh
			//}

			function createPlanetMesh(path, geom) {
				var planetTexture = THREE.ImageUtils.loadTexture(path);
				var planetMaterial = new THREE.MeshPhongMaterial();
				planetMaterial.map = planetTexture;
				// create a multimaterial
				var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [planetMaterial]);
				return mesh;
			}

			function createSunGlow() {
				var spriteMaterial = new THREE.SpriteMaterial( {
					map: new THREE.ImageUtils.loadTexture('../glow.png'),
					useScreenCoordinates: false,
					color: 0xff8300,
					depthWrite: false,
					transparent: false,
					blending: THREE.AdditiveBlending
				})
				var sprite = new THREE.Sprite(spriteMaterial);
				sprite.scale.set(100,100,1);
				return sprite;
	}

			function createRings(geom) {
					var ringsTexture = THREE.ImageUtils.loadTexture("../saturn rings.jpg");
					ringsTexture.wrapS = THREE.RepeatWrapping;
					ringsTexture.repeat.set( 1, 1 );
					var ringsMaterial = new THREE.MeshPhongMaterial();
					ringsMaterial.map = ringsTexture;
					// create a multimaterial
					var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [ringsMaterial]);
					ringsTexture.material = THREE.DoubleSide;
					return mesh;

			}

			function initRenderer(){
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function initScene(){
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x2859a8 );
				// scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
			}

			function initSolarCam() {
				solarCam = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				solarCam.position.x = -10;
        solarCam.position.y = 15;
        solarCam.position.z = 100;
        solarCam.lookAt(new THREE.Vector3(0, 0, 0));
			}

			function initPlanetCams() {
				mercuryCam = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				scene.add(mercuryCam);
				// mercury.add(mercuryCam);
				// mercuryCam.translateZ(3);

				venusCam = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				venus.add(venusCam);
				venusCam.translateZ(3);

				earthCam = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				earth.add(earthCam);
				earthCam.translateZ(3);

				marsCam = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				mars.add(marsCam);
				marsCam.translateZ(3);

				jupiterCam = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				jupiter.add(jupiterCam);
				jupiterCam.translateZ(20);

				saturnCam = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				saturn.add(saturnCam);
				saturnCam.translateZ(25);

				uranusCam = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				uranus.add(uranusCam);
				uranusCam.translateZ(8);

				neptuneCam = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				neptune.add(neptuneCam);
				neptuneCam.translateZ(8);
			}


			function initControls(){
				controls = new THREE.OrbitControls( solarCam, renderer.domElement );
				controls.enableZoom = false;

				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.25;

				controls.panningMode = THREE.HorizontalPanning; // default is THREE.ScreenSpacePanning

				controls.minDistance = 10;
				controls.maxDistance = 500;
				controls.maxPolarAngle = Math.PI / 2;

				clock = new THREE.Clock();
				clock.start;
			}

			function onWindowResize() {
				solarCam.aspect = window.innerWidth / window.innerHeight;
				solarCam.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update();

				var delta = clock.getDelta();
				controls.update(delta);

				// Mercury
				mercury.position.x = Math.sin( Date.now() * 0.000047 ) * mercuryRadius;
				mercury.position.z = Math.cos( Date.now() * 0.000047 ) * mercuryRadius;
				mercury.rotateY(0.005);
				// Venus
				venus.position.x = Math.sin( Date.now() * 0.000035 ) * venusRadius;
				venus.position.z = Math.cos( Date.now() * 0.000035 ) * venusRadius;
				venus.rotateY(0.005);
				// Earth
				earth.position.x = Math.sin( Date.now() * 0.000029 ) * earthRadius;
				earth.position.z = Math.cos( Date.now() * 0.000029 ) * earthRadius;
				earth.rotateY(0.005);
				// Mars
				mars.position.x = Math.sin( Date.now() * 0.000024 ) * marsRadius;
				mars.position.z = Math.cos( Date.now() * 0.000024 ) * marsRadius;
				mars.rotateY(0.005);
				// Jupiter
				jupiter.position.x = Math.sin( Date.now() * 0.000013 ) * jupiterRadius;
				jupiter.position.z = Math.cos( Date.now() * 0.000013 ) * jupiterRadius;
				jupiter.rotateY(0.005);
				// Saturn
				saturn.position.x = Math.sin( Date.now() * 0.00009 ) * saturnRadius;
				saturn.position.z = Math.cos( Date.now() * 0.00009 ) * saturnRadius;
				saturn.rotateY(0.005);
				//Rings
				rings.position.x = Math.sin( Date.now() * 0.00009 ) * saturnRadius;
		    rings.position.z = Math.cos( Date.now() * 0.00009 ) * saturnRadius;
				rings.rotation.x = Math.PI/(-30) ;
       	rings.rotation.z = Math.PI/(10) ;
				// Uranus
				uranus.position.x = Math.sin( Date.now() * 0.00006 ) * uranusRadius;
				uranus.position.z = Math.cos( Date.now() * 0.00006 ) * uranusRadius;
				uranus.rotateY(0.005);
				// Neptune
				neptune.position.x = Math.sin( Date.now() * 0.00005 ) * neptuneRadius;
				neptune.position.z = Math.cos( Date.now() * 0.00005 ) * neptuneRadius;
				neptune.rotateY(0.005);

				switch(camControls.camera){
					case 'Solar View':
						renderer.render( scene, solarCam );
						break;
					case 'Mercury':
						mercuryCam.position.x = Math.sin( Date.now() * 0.000047 ) * (mercuryRadius+3);
						mercuryCam.position.z = Math.cos( Date.now() * 0.000047 ) * (mercuryRadius+3);
						mercuryCam.lookAt(new THREE.Vector3(mercury.position.x, mercury.position.y,mercury.position.z));
						renderer.render(scene, mercuryCam);
						break;
					case 'Venus':
						renderer.render(scene, venusCam);
						break;
					case 'Earth':
						renderer.render(scene, earthCam);
						break;
					case 'Mars':
						renderer.render(scene, marsCam);
						break;
					case 'Jupiter':
						renderer.render(scene, jupiterCam);
						break;
					case 'Saturn':
						renderer.render(scene, saturnCam);
						break;
					case 'Uranus':
						renderer.render(scene, uranusCam);
						break;
					case 'Neptune':
						renderer.render(scene, neptuneCam);
						break;
				}
			}


		</script>

	</body>
</html>
